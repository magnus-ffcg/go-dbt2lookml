<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# models

```go
import "github.com/magnus-ffcg/go-dbt2lookml/pkg/models"
```

Package models defines data structures for dbt and LookML representations.

This package contains the domain models used throughout the application, including dbt artifacts \(models, columns, metadata\) and LookML structures \(views, dimensions, measures, explores\).

dbt Models:

- DbtModel: Represents a dbt model with columns and metadata
- DbtModelColumn: Column definition with data type and metadata
- DbtCatalog: Parsed catalog.json structure
- DbtManifest: Parsed manifest.json structure
- DbtExposure: dbt exposure definitions

LookML Models:

- LookMLView: Complete LookML view structure
- LookMLDimension: Dimension field definition
- LookMLDimensionGroup: Dimension group for dates/timestamps
- LookMLMeasure: Measure field definition
- LookMLExplore: Explore with joins

Metadata:

- DbtMetaLooker: Custom LookML metadata from dbt meta tags
- DbtMetaLookerDimension: Dimension\-specific metadata
- DbtMetaLookerMeasure: Measure\-specific metadata

All LookML models include Validate\(\) methods to ensure data integrity before generation.

## Index

- [Constants](<#constants>)
- [type ColumnCategory](<#ColumnCategory>)
- [type ColumnClassifier](<#ColumnClassifier>)
  - [func NewColumnClassifier\(hierarchy \*ColumnHierarchy, arrayColumns map\[string\]bool\) \*ColumnClassifier](<#NewColumnClassifier>)
  - [func \(c \*ColumnClassifier\) Classify\(columnName string, column DbtModelColumn\) ColumnCategory](<#ColumnClassifier.Classify>)
  - [func \(c \*ColumnClassifier\) GetArrayParent\(columnName string\) string](<#ColumnClassifier.GetArrayParent>)
  - [func \(c \*ColumnClassifier\) HasChildren\(columnName string\) bool](<#ColumnClassifier.HasChildren>)
  - [func \(c \*ColumnClassifier\) IsNestedArray\(columnName string\) bool](<#ColumnClassifier.IsNestedArray>)
- [type ColumnCollections](<#ColumnCollections>)
  - [func NewColumnCollections\(model \*DbtModel, arrayModels \[\]string\) \*ColumnCollections](<#NewColumnCollections>)
  - [func NewColumnCollectionsV2\(model \*DbtModel, arrayModels \[\]string\) \*ColumnCollections](<#NewColumnCollectionsV2>)
  - [func \(cc \*ColumnCollections\) GetArrayModels\(\) \[\]string](<#ColumnCollections.GetArrayModels>)
- [type ColumnHierarchy](<#ColumnHierarchy>)
  - [func NewColumnHierarchy\(columns map\[string\]DbtModelColumn\) \*ColumnHierarchy](<#NewColumnHierarchy>)
  - [func \(h \*ColumnHierarchy\) All\(\) map\[string\]\*HierarchyInfo](<#ColumnHierarchy.All>)
  - [func \(h \*ColumnHierarchy\) Get\(path string\) \*HierarchyInfo](<#ColumnHierarchy.Get>)
  - [func \(h \*ColumnHierarchy\) GetChildren\(path string\) \[\]string](<#ColumnHierarchy.GetChildren>)
  - [func \(h \*ColumnHierarchy\) HasChildren\(path string\) bool](<#ColumnHierarchy.HasChildren>)
  - [func \(h \*ColumnHierarchy\) IsArray\(path string\) bool](<#ColumnHierarchy.IsArray>)
- [type DbtBaseModel](<#DbtBaseModel>)
- [type DbtCatalog](<#DbtCatalog>)
- [type DbtCatalogNode](<#DbtCatalogNode>)
  - [func \(n \*DbtCatalogNode\) NormalizeColumnNames\(\)](<#DbtCatalogNode.NormalizeColumnNames>)
- [type DbtCatalogNodeColumn](<#DbtCatalogNodeColumn>)
  - [func \(c \*DbtCatalogNodeColumn\) ProcessColumnType\(\)](<#DbtCatalogNodeColumn.ProcessColumnType>)
- [type DbtCatalogNodeMetadata](<#DbtCatalogNodeMetadata>)
- [type DbtDependsOn](<#DbtDependsOn>)
- [type DbtExposure](<#DbtExposure>)
- [type DbtExposureRef](<#DbtExposureRef>)
- [type DbtManifest](<#DbtManifest>)
- [type DbtManifestMetadata](<#DbtManifestMetadata>)
  - [func \(m \*DbtManifestMetadata\) ValidateAdapter\(\) error](<#DbtManifestMetadata.ValidateAdapter>)
- [type DbtMetaLooker](<#DbtMetaLooker>)
- [type DbtMetaLookerBase](<#DbtMetaLookerBase>)
- [type DbtMetaLookerDimension](<#DbtMetaLookerDimension>)
- [type DbtMetaLookerJoin](<#DbtMetaLookerJoin>)
- [type DbtMetaLookerMeasure](<#DbtMetaLookerMeasure>)
  - [func \(m \*DbtMetaLookerMeasure\) ValidateMeasureAttributes\(\) error](<#DbtMetaLookerMeasure.ValidateMeasureAttributes>)
- [type DbtMetaLookerMeasureFilter](<#DbtMetaLookerMeasureFilter>)
- [type DbtModel](<#DbtModel>)
  - [func \(m \*DbtModel\) NormalizeColumnNames\(\)](<#DbtModel.NormalizeColumnNames>)
- [type DbtModelColumn](<#DbtModelColumn>)
  - [func \(c \*DbtModelColumn\) GetDataTypeUpper\(\) string](<#DbtModelColumn.GetDataTypeUpper>)
  - [func \(c \*DbtModelColumn\) IsArrayColumn\(\) bool](<#DbtModelColumn.IsArrayColumn>)
  - [func \(c \*DbtModelColumn\) IsDateTimeColumn\(\) bool](<#DbtModelColumn.IsDateTimeColumn>)
  - [func \(c \*DbtModelColumn\) IsSimpleArrayColumn\(\) bool](<#DbtModelColumn.IsSimpleArrayColumn>)
  - [func \(c \*DbtModelColumn\) IsStructColumn\(\) bool](<#DbtModelColumn.IsStructColumn>)
  - [func \(c \*DbtModelColumn\) ProcessColumn\(\)](<#DbtModelColumn.ProcessColumn>)
- [type DbtModelColumnMeta](<#DbtModelColumnMeta>)
- [type DbtModelMeta](<#DbtModelMeta>)
- [type DbtNode](<#DbtNode>)
- [type DimensionConflictResolver](<#DimensionConflictResolver>)
  - [func NewDimensionConflictResolver\(cfg \*config.Config\) \*DimensionConflictResolver](<#NewDimensionConflictResolver>)
  - [func NewDimensionConflictResolverWithOptions\(suffix string, hideConflicts bool, cfg \*config.Config\) \*DimensionConflictResolver](<#NewDimensionConflictResolverWithOptions>)
  - [func \(r \*DimensionConflictResolver\) GetConflictingDimensions\(dimensions \[\]LookMLDimension, dimensionGroups \[\]LookMLDimensionGroup\) \[\]string](<#DimensionConflictResolver.GetConflictingDimensions>)
  - [func \(r \*DimensionConflictResolver\) GetReservedNames\(dimensionGroups \[\]LookMLDimensionGroup\) \[\]string](<#DimensionConflictResolver.GetReservedNames>)
  - [func \(r \*DimensionConflictResolver\) Resolve\(dimensions \[\]LookMLDimension, dimensionGroups \[\]LookMLDimensionGroup, modelName string\) \[\]LookMLDimension](<#DimensionConflictResolver.Resolve>)
- [type HierarchyInfo](<#HierarchyInfo>)
- [type LookMLDimension](<#LookMLDimension>)
  - [func \(d \*LookMLDimension\) Validate\(\) error](<#LookMLDimension.Validate>)
- [type LookMLDimensionGroup](<#LookMLDimensionGroup>)
- [type LookMLExplore](<#LookMLExplore>)
- [type LookMLJoin](<#LookMLJoin>)
- [type LookMLMeasure](<#LookMLMeasure>)
  - [func \(m \*LookMLMeasure\) Validate\(\) error](<#LookMLMeasure.Validate>)
- [type LookMLView](<#LookMLView>)
  - [func \(v \*LookMLView\) Validate\(\) error](<#LookMLView.Validate>)
- [type LookViewFile](<#LookViewFile>)
- [type NestedArrayRules](<#NestedArrayRules>)
  - [func NewNestedArrayRules\(\) \*NestedArrayRules](<#NewNestedArrayRules>)
  - [func NewNestedArrayRulesWithDepth\(maxDepth int\) \*NestedArrayRules](<#NewNestedArrayRulesWithDepth>)
  - [func \(r \*NestedArrayRules\) GetArrayDepth\(arrayPath string\) int](<#NestedArrayRules.GetArrayDepth>)
  - [func \(r \*NestedArrayRules\) GetMaxDepth\(\) int](<#NestedArrayRules.GetMaxDepth>)
  - [func \(r \*NestedArrayRules\) IsValidArrayPath\(arrayPath string\) bool](<#NestedArrayRules.IsValidArrayPath>)
  - [func \(r \*NestedArrayRules\) ShouldProcessArray\(arrayPath string\) bool](<#NestedArrayRules.ShouldProcessArray>)


## Constants

<a name="MaxNestedArrayDepth"></a>MaxNestedArrayDepth defines the maximum nesting level for array processing.

Nesting levels:

- Level 1: items \(0 dots in path\)
- Level 2: items.subitems \(1 dot in path\)
- Level 3: items.subitems.details \(2 dots in path\)
- Level 4\+: Considered too deeply nested \(3\+ dots\)

Arrays beyond Level 3 are typically too complex for efficient querying and can cause performance issues in most BI tools.

```go
const MaxNestedArrayDepth = 3
```

<a name="ColumnCategory"></a>
## type ColumnCategory

ColumnCategory represents where a column should be placed.

```go
type ColumnCategory int
```

<a name="CategoryExcluded"></a>

```go
const (
    // CategoryExcluded means the column should be excluded from all views
    CategoryExcluded ColumnCategory = iota
    // CategoryMainView means the column belongs in the main view
    CategoryMainView
    // CategoryNestedView means the column belongs in a nested view
    CategoryNestedView
)
```

<a name="ColumnClassifier"></a>
## type ColumnClassifier

ColumnClassifier determines where each column should be placed based on business rules for BigQuery nested structures \(ARRAY, STRUCT\).

```go
type ColumnClassifier struct {
    // contains filtered or unexported fields
}
```

<a name="NewColumnClassifier"></a>
### func NewColumnClassifier

```go
func NewColumnClassifier(hierarchy *ColumnHierarchy, arrayColumns map[string]bool) *ColumnClassifier
```

NewColumnClassifier creates a classifier with the given hierarchy and array columns.

<a name="ColumnClassifier.Classify"></a>
### func \(\*ColumnClassifier\) Classify

```go
func (c *ColumnClassifier) Classify(columnName string, column DbtModelColumn) ColumnCategory
```

Classify determines the category for a given column.

<a name="ColumnClassifier.GetArrayParent"></a>
### func \(\*ColumnClassifier\) GetArrayParent

```go
func (c *ColumnClassifier) GetArrayParent(columnName string) string
```

GetArrayParent returns the array parent for a column, if any.

<a name="ColumnClassifier.HasChildren"></a>
### func \(\*ColumnClassifier\) HasChildren

```go
func (c *ColumnClassifier) HasChildren(columnName string) bool
```

HasChildren checks if a column has child columns.

<a name="ColumnClassifier.IsNestedArray"></a>
### func \(\*ColumnClassifier\) IsNestedArray

```go
func (c *ColumnClassifier) IsNestedArray(columnName string) bool
```

IsNestedArray checks if an array column is nested under another array.

<a name="ColumnCollections"></a>
## type ColumnCollections

ColumnCollections organizes model columns by their intended use

```go
type ColumnCollections struct {
    MainViewColumns   map[string]DbtModelColumn            // Columns for the main view
    NestedViewColumns map[string]map[string]DbtModelColumn // array_name -> columns for nested views
    ExcludedColumns   map[string]DbtModelColumn            // Columns excluded from all views
}
```

<a name="NewColumnCollections"></a>
### func NewColumnCollections

```go
func NewColumnCollections(model *DbtModel, arrayModels []string) *ColumnCollections
```

FromModel creates column collections from a dbt model with optimized processing

<a name="NewColumnCollectionsV2"></a>
### func NewColumnCollectionsV2

```go
func NewColumnCollectionsV2(model *DbtModel, arrayModels []string) *ColumnCollections
```

NewColumnCollectionsV2 creates column collections using the refactored services. This is a cleaner implementation that delegates to specialized services.

<a name="ColumnCollections.GetArrayModels"></a>
### func \(\*ColumnCollections\) GetArrayModels

```go
func (cc *ColumnCollections) GetArrayModels() []string
```

GetArrayModels extracts all array models from the column collections

<a name="ColumnHierarchy"></a>
## type ColumnHierarchy

ColumnHierarchy represents the parent\-child relationships between columns. It's used to understand nested STRUCT and ARRAY structures in BigQuery.

```go
type ColumnHierarchy struct {
    // contains filtered or unexported fields
}
```

<a name="NewColumnHierarchy"></a>
### func NewColumnHierarchy

```go
func NewColumnHierarchy(columns map[string]DbtModelColumn) *ColumnHierarchy
```

NewColumnHierarchy builds a hierarchy from a flat map of columns. It analyzes dot\-separated paths to build parent\-child relationships.

<a name="ColumnHierarchy.All"></a>
### func \(\*ColumnHierarchy\) All

```go
func (h *ColumnHierarchy) All() map[string]*HierarchyInfo
```

All returns the entire hierarchy map.

<a name="ColumnHierarchy.Get"></a>
### func \(\*ColumnHierarchy\) Get

```go
func (h *ColumnHierarchy) Get(path string) *HierarchyInfo
```

Get returns the hierarchy info for a given column path.

<a name="ColumnHierarchy.GetChildren"></a>
### func \(\*ColumnHierarchy\) GetChildren

```go
func (h *ColumnHierarchy) GetChildren(path string) []string
```

GetChildren returns all child paths for a given column.

<a name="ColumnHierarchy.HasChildren"></a>
### func \(\*ColumnHierarchy\) HasChildren

```go
func (h *ColumnHierarchy) HasChildren(path string) bool
```

HasChildren checks if a column has any child columns.

<a name="ColumnHierarchy.IsArray"></a>
### func \(\*ColumnHierarchy\) IsArray

```go
func (h *ColumnHierarchy) IsArray(path string) bool
```

IsArray checks if a column is an ARRAY type.

<a name="DbtBaseModel"></a>
## type DbtBaseModel

DbtBaseModel represents the base model for dbt objects

```go
type DbtBaseModel struct{}
```

<a name="DbtCatalog"></a>
## type DbtCatalog

DbtCatalog represents a dbt catalog

```go
type DbtCatalog struct {
    Nodes map[string]DbtCatalogNode `json:"nodes" yaml:"nodes"`
}
```

<a name="DbtCatalogNode"></a>
## type DbtCatalogNode

DbtCatalogNode represents a dbt catalog node

```go
type DbtCatalogNode struct {
    Metadata DbtCatalogNodeMetadata          `json:"metadata" yaml:"metadata"`
    Columns  map[string]DbtCatalogNodeColumn `json:"columns" yaml:"columns"`
}
```

<a name="DbtCatalogNode.NormalizeColumnNames"></a>
### func \(\*DbtCatalogNode\) NormalizeColumnNames

```go
func (n *DbtCatalogNode) NormalizeColumnNames()
```

NormalizeColumnNames converts all column names to lowercase for case\-insensitive matching but preserves the original name for LookML generation

<a name="DbtCatalogNodeColumn"></a>
## type DbtCatalogNodeColumn

DbtCatalogNodeColumn represents a column in a dbt catalog node

```go
type DbtCatalogNodeColumn struct {
    Type         string                `json:"type" yaml:"type"`
    DataType     string                `json:"data_type" yaml:"data_type"`
    InnerTypes   []string              `json:"inner_types" yaml:"inner_types"`
    Comment      *string               `json:"comment,omitempty" yaml:"comment,omitempty"`
    Index        int                   `json:"index" yaml:"index"`
    Name         string                `json:"name" yaml:"name"`
    OriginalName string                `json:"original_name" yaml:"original_name"`
    Parent       *DbtCatalogNodeColumn `json:"parent,omitempty" yaml:"parent,omitempty"`
}
```

<a name="DbtCatalogNodeColumn.ProcessColumnType"></a>
### func \(\*DbtCatalogNodeColumn\) ProcessColumnType

```go
func (c *DbtCatalogNodeColumn) ProcessColumnType()
```

ProcessColumnType processes the column type and extracts data type and inner types

<a name="DbtCatalogNodeMetadata"></a>
## type DbtCatalogNodeMetadata

DbtCatalogNodeMetadata represents metadata about a dbt catalog node

```go
type DbtCatalogNodeMetadata struct {
    Type    string  `json:"type" yaml:"type"`
    Schema  string  `json:"schema" yaml:"schema"`
    Name    string  `json:"name" yaml:"name"`
    Comment *string `json:"comment,omitempty" yaml:"comment,omitempty"`
    Owner   *string `json:"owner,omitempty" yaml:"owner,omitempty"`
}
```

<a name="DbtDependsOn"></a>
## type DbtDependsOn

DbtDependsOn represents dependencies between dbt objects

```go
type DbtDependsOn struct {
    Macros []string `json:"macros" yaml:"macros"`
    Nodes  []string `json:"nodes" yaml:"nodes"`
}
```

<a name="DbtExposure"></a>
## type DbtExposure

DbtExposure represents a dbt exposure

```go
type DbtExposure struct {
    DbtNode
    Description *string          `json:"description,omitempty" yaml:"description,omitempty"`
    URL         *string          `json:"url,omitempty" yaml:"url,omitempty"`
    Refs        []DbtExposureRef `json:"refs" yaml:"refs"`
    Tags        []string         `json:"tags" yaml:"tags"`
    DependsOn   DbtDependsOn     `json:"depends_on" yaml:"depends_on"`
}
```

<a name="DbtExposureRef"></a>
## type DbtExposureRef

DbtExposureRef represents a reference in a dbt exposure

```go
type DbtExposureRef struct {
    Name    string      `json:"name" yaml:"name"`
    Package *string     `json:"package,omitempty" yaml:"package,omitempty"`
    Version interface{} `json:"version,omitempty" yaml:"version,omitempty"` // Can be string or int
}
```

<a name="DbtManifest"></a>
## type DbtManifest

DbtManifest represents a dbt manifest

```go
type DbtManifest struct {
    Nodes     map[string]interface{} `json:"nodes" yaml:"nodes"` // Can be DbtModel or DbtNode
    Metadata  DbtManifestMetadata    `json:"metadata" yaml:"metadata"`
    Exposures map[string]DbtExposure `json:"exposures" yaml:"exposures"`
}
```

<a name="DbtManifestMetadata"></a>
## type DbtManifestMetadata

DbtManifestMetadata represents metadata about a dbt manifest

```go
type DbtManifestMetadata struct {
    AdapterType string `json:"adapter_type" yaml:"adapter_type"`
}
```

<a name="DbtManifestMetadata.ValidateAdapter"></a>
### func \(\*DbtManifestMetadata\) ValidateAdapter

```go
func (m *DbtManifestMetadata) ValidateAdapter() error
```

ValidateAdapter validates that the adapter type is supported

<a name="DbtMetaLooker"></a>
## type DbtMetaLooker

DbtMetaLooker represents Looker metadata for a model

```go
type DbtMetaLooker struct {
    View      *DbtMetaLookerBase      `json:"view,omitempty" yaml:"view,omitempty"`
    Dimension *DbtMetaLookerDimension `json:"dimension,omitempty" yaml:"dimension,omitempty"`
    Measures  []DbtMetaLookerMeasure  `json:"measures,omitempty" yaml:"measures,omitempty"`
    Joins     []DbtMetaLookerJoin     `json:"joins,omitempty" yaml:"joins,omitempty"`
}
```

<a name="DbtMetaLookerBase"></a>
## type DbtMetaLookerBase

DbtMetaLookerBase represents the base class for Looker metadata

```go
type DbtMetaLookerBase struct {
    Label       *string `json:"label,omitempty" yaml:"label,omitempty"`
    Description *string `json:"description,omitempty" yaml:"description,omitempty"`
    Hidden      *bool   `json:"hidden,omitempty" yaml:"hidden,omitempty"`
}
```

<a name="DbtMetaLookerDimension"></a>
## type DbtMetaLookerDimension

DbtMetaLookerDimension represents Looker\-specific metadata for a dimension

```go
type DbtMetaLookerDimension struct {
    DbtMetaLookerBase
    ConvertTZ       *bool                        `json:"convert_tz,omitempty" yaml:"convert_tz,omitempty"`
    GroupLabel      *string                      `json:"group_label,omitempty" yaml:"group_label,omitempty"`
    ValueFormatName *enums.LookerValueFormatName `json:"value_format_name,omitempty" yaml:"value_format_name,omitempty"`
    Timeframes      []enums.LookerTimeFrame      `json:"timeframes,omitempty" yaml:"timeframes,omitempty"`
    CanFilter       interface{}                  `json:"can_filter,omitempty" yaml:"can_filter,omitempty"` // Can be bool or string
}
```

<a name="DbtMetaLookerJoin"></a>
## type DbtMetaLookerJoin

DbtMetaLookerJoin represents Looker\-specific metadata for joins

```go
type DbtMetaLookerJoin struct {
    JoinModel    *string                       `json:"join_model,omitempty" yaml:"join_model,omitempty"`
    SQLON        *string                       `json:"sql_on,omitempty" yaml:"sql_on,omitempty"`
    Type         *enums.LookerJoinType         `json:"type,omitempty" yaml:"type,omitempty"`
    Relationship *enums.LookerRelationshipType `json:"relationship,omitempty" yaml:"relationship,omitempty"`
}
```

<a name="DbtMetaLookerMeasure"></a>
## type DbtMetaLookerMeasure

DbtMetaLookerMeasure represents Looker metadata for a measure

```go
type DbtMetaLookerMeasure struct {
    DbtMetaLookerBase
    // Required fields
    Type enums.LookerMeasureType `json:"type" yaml:"type"`

    // Common optional fields
    Name            *string                      `json:"name,omitempty" yaml:"name,omitempty"`
    GroupLabel      *string                      `json:"group_label,omitempty" yaml:"group_label,omitempty"`
    ValueFormatName *enums.LookerValueFormatName `json:"value_format_name,omitempty" yaml:"value_format_name,omitempty"`
    Filters         []DbtMetaLookerMeasureFilter `json:"filters,omitempty" yaml:"filters,omitempty"`

    // Fields specific to certain measure types
    Approximate          *bool   `json:"approximate,omitempty" yaml:"approximate,omitempty"`                     // For count_distinct
    ApproximateThreshold *int    `json:"approximate_threshold,omitempty" yaml:"approximate_threshold,omitempty"` // For count_distinct
    Precision            *int    `json:"precision,omitempty" yaml:"precision,omitempty"`                         // For average, sum
    SQLDistinctKey       *string `json:"sql_distinct_key,omitempty" yaml:"sql_distinct_key,omitempty"`           // For count_distinct
    Percentile           *int    `json:"percentile,omitempty" yaml:"percentile,omitempty"`                       // For percentile measures
}
```

<a name="DbtMetaLookerMeasure.ValidateMeasureAttributes"></a>
### func \(\*DbtMetaLookerMeasure\) ValidateMeasureAttributes

```go
func (m *DbtMetaLookerMeasure) ValidateMeasureAttributes() error
```

ValidateMeasureAttributes validates that measure attributes are compatible with the measure type

<a name="DbtMetaLookerMeasureFilter"></a>
## type DbtMetaLookerMeasureFilter

DbtMetaLookerMeasureFilter represents a filter for Looker measures

```go
type DbtMetaLookerMeasureFilter struct {
    FilterDimension  string `json:"filter_dimension" yaml:"filter_dimension"`
    FilterExpression string `json:"filter_expression" yaml:"filter_expression"`
}
```

<a name="DbtModel"></a>
## type DbtModel

DbtModel represents a dbt model

```go
type DbtModel struct {
    DbtNode
    ResourceType string                    `json:"resource_type" yaml:"resource_type"`
    RelationName string                    `json:"relation_name" yaml:"relation_name"`
    Schema       string                    `json:"schema" yaml:"schema"`
    Description  string                    `json:"description" yaml:"description"`
    Columns      map[string]DbtModelColumn `json:"columns" yaml:"columns"`
    Tags         []string                  `json:"tags" yaml:"tags"`
    Meta         *DbtModelMeta             `json:"meta,omitempty" yaml:"meta,omitempty"`
    Path         string                    `json:"path" yaml:"path"`
}
```

<a name="DbtModel.NormalizeColumnNames"></a>
### func \(\*DbtModel\) NormalizeColumnNames

```go
func (m *DbtModel) NormalizeColumnNames()
```

NormalizeColumnNames converts all column names to lowercase for case\-insensitive matching

<a name="DbtModelColumn"></a>
## type DbtModelColumn

DbtModelColumn represents a column in a dbt model

```go
type DbtModelColumn struct {
    Name           string              `json:"name" yaml:"name"`
    Description    *string             `json:"description,omitempty" yaml:"description,omitempty"`
    LookMLLongName *string             `json:"lookml_long_name,omitempty" yaml:"lookml_long_name,omitempty"`
    LookMLName     *string             `json:"lookml_name,omitempty" yaml:"lookml_name,omitempty"`
    OriginalName   *string             `json:"original_name,omitempty" yaml:"original_name,omitempty"`
    DataType       *string             `json:"data_type,omitempty" yaml:"data_type,omitempty"`
    InnerTypes     []string            `json:"inner_types" yaml:"inner_types"`
    Meta           *DbtModelColumnMeta `json:"meta,omitempty" yaml:"meta,omitempty"`
    Nested         bool                `json:"nested" yaml:"nested"`
    IsPrimaryKey   bool                `json:"is_primary_key" yaml:"is_primary_key"`
}
```

<a name="DbtModelColumn.GetDataTypeUpper"></a>
### func \(\*DbtModelColumn\) GetDataTypeUpper

```go
func (c *DbtModelColumn) GetDataTypeUpper() string
```

GetDataTypeUpper returns the uppercase data type string, or empty string if nil

<a name="DbtModelColumn.IsArrayColumn"></a>
### func \(\*DbtModelColumn\) IsArrayColumn

```go
func (c *DbtModelColumn) IsArrayColumn() bool
```

IsArrayColumn returns true if the column is an ARRAY type

<a name="DbtModelColumn.IsDateTimeColumn"></a>
### func \(\*DbtModelColumn\) IsDateTimeColumn

```go
func (c *DbtModelColumn) IsDateTimeColumn() bool
```

IsDateTimeColumn returns true if the column is a date/time type \(DATE, DATETIME, TIMESTAMP\)

<a name="DbtModelColumn.IsSimpleArrayColumn"></a>
### func \(\*DbtModelColumn\) IsSimpleArrayColumn

```go
func (c *DbtModelColumn) IsSimpleArrayColumn() bool
```

IsSimpleArrayColumn returns true if the column is a simple ARRAY without STRUCT \(e.g., ARRAY\<STRING\>, ARRAY\<INT64\>\)

<a name="DbtModelColumn.IsStructColumn"></a>
### func \(\*DbtModelColumn\) IsStructColumn

```go
func (c *DbtModelColumn) IsStructColumn() bool
```

IsStructColumn returns true if the column is a STRUCT type

<a name="DbtModelColumn.ProcessColumn"></a>
### func \(\*DbtModelColumn\) ProcessColumn

```go
func (c *DbtModelColumn) ProcessColumn()
```

ProcessColumn processes the column and sets derived fields

<a name="DbtModelColumnMeta"></a>
## type DbtModelColumnMeta

DbtModelColumnMeta represents metadata about a column in a dbt model

```go
type DbtModelColumnMeta struct {
    Looker *DbtMetaLooker `json:"looker,omitempty" yaml:"looker,omitempty"`
}
```

<a name="DbtModelMeta"></a>
## type DbtModelMeta

DbtModelMeta represents metadata about a dbt model

```go
type DbtModelMeta struct {
    Looker *DbtMetaLooker `json:"looker,omitempty" yaml:"looker,omitempty"`
}
```

<a name="DbtNode"></a>
## type DbtNode

DbtNode represents a dbt node, extensible to models, seeds, etc.

```go
type DbtNode struct {
    Name         string                `json:"name" yaml:"name"`
    UniqueID     string                `json:"unique_id" yaml:"unique_id"`
    ResourceType enums.DbtResourceType `json:"resource_type" yaml:"resource_type"`
}
```

<a name="DimensionConflictResolver"></a>
## type DimensionConflictResolver

DimensionConflictResolver handles conflicts between dimensions and dimension groups.

When a dimension has the same name as a dimension group or one of its timeframe variations, it creates a naming conflict in LookML. This resolver detects such conflicts and renames the conflicting dimensions by adding a "\_conflict" suffix and marking them as hidden.

Example conflict:

- Dimension: "created\_date" \(from STRUCT field or nested column\)
- Dimension Group: "created" with timeframe "date" → generates "created\_date"
- Resolution: Rename dimension to "created\_date\_conflict" and hide it

```go
type DimensionConflictResolver struct {
    // contains filtered or unexported fields
}
```

<a name="NewDimensionConflictResolver"></a>
### func NewDimensionConflictResolver

```go
func NewDimensionConflictResolver(cfg *config.Config) *DimensionConflictResolver
```

NewDimensionConflictResolver creates a new resolver with default settings.

<a name="NewDimensionConflictResolverWithOptions"></a>
### func NewDimensionConflictResolverWithOptions

```go
func NewDimensionConflictResolverWithOptions(suffix string, hideConflicts bool, cfg *config.Config) *DimensionConflictResolver
```

NewDimensionConflictResolverWithOptions creates a resolver with custom settings.

<a name="DimensionConflictResolver.GetConflictingDimensions"></a>
### func \(\*DimensionConflictResolver\) GetConflictingDimensions

```go
func (r *DimensionConflictResolver) GetConflictingDimensions(dimensions []LookMLDimension, dimensionGroups []LookMLDimensionGroup) []string
```

GetConflictingDimensions returns a list of dimension names that conflict with dimension groups. Useful for debugging or reporting.

<a name="DimensionConflictResolver.GetReservedNames"></a>
### func \(\*DimensionConflictResolver\) GetReservedNames

```go
func (r *DimensionConflictResolver) GetReservedNames(dimensionGroups []LookMLDimensionGroup) []string
```

GetReservedNames returns all names that are reserved by dimension groups. Useful for validation or documentation.

<a name="DimensionConflictResolver.Resolve"></a>
### func \(\*DimensionConflictResolver\) Resolve

```go
func (r *DimensionConflictResolver) Resolve(dimensions []LookMLDimension, dimensionGroups []LookMLDimensionGroup, modelName string) []LookMLDimension
```

Resolve detects and resolves naming conflicts between dimensions and dimension groups. Returns a new slice with conflicting dimensions renamed and optionally hidden.

<a name="HierarchyInfo"></a>
## type HierarchyInfo

HierarchyInfo contains information about a column's position in the hierarchy.

```go
type HierarchyInfo struct {
    Children []string        // Child column paths
    IsArray  bool            // Whether this column is an ARRAY type
    Column   *DbtModelColumn // Reference to the actual column
}
```

<a name="LookMLDimension"></a>
## type LookMLDimension

LookMLDimension represents a dimension in LookML

```go
type LookMLDimension struct {
    Name            string                       `json:"name" yaml:"name"`
    Type            string                       `json:"type" yaml:"type"`
    SQL             string                       `json:"sql" yaml:"sql"`
    Label           *string                      `json:"label,omitempty" yaml:"label,omitempty"`
    Description     *string                      `json:"description,omitempty" yaml:"description,omitempty"`
    Hidden          *bool                        `json:"hidden,omitempty" yaml:"hidden,omitempty"`
    GroupLabel      *string                      `json:"group_label,omitempty" yaml:"group_label,omitempty"`
    GroupItemLabel  *string                      `json:"group_item_label,omitempty" yaml:"group_item_label,omitempty"`
    ValueFormatName *enums.LookerValueFormatName `json:"value_format_name,omitempty" yaml:"value_format_name,omitempty"`
    CanFilter       *bool                        `json:"can_filter,omitempty" yaml:"can_filter,omitempty"`
    ConvertTZ       *bool                        `json:"convert_tz,omitempty" yaml:"convert_tz,omitempty"`
}
```

<a name="LookMLDimension.Validate"></a>
### func \(\*LookMLDimension\) Validate

```go
func (d *LookMLDimension) Validate() error
```

Validate checks if the dimension has all required fields

<a name="LookMLDimensionGroup"></a>
## type LookMLDimensionGroup

LookMLDimensionGroup represents a dimension group in LookML

```go
type LookMLDimensionGroup struct {
    Name        string                  `json:"name" yaml:"name"`
    Type        string                  `json:"type" yaml:"type"`
    SQL         string                  `json:"sql" yaml:"sql"`
    Label       *string                 `json:"label,omitempty" yaml:"label,omitempty"`
    Description *string                 `json:"description,omitempty" yaml:"description,omitempty"`
    Hidden      *bool                   `json:"hidden,omitempty" yaml:"hidden,omitempty"`
    GroupLabel  *string                 `json:"group_label,omitempty" yaml:"group_label,omitempty"`
    Timeframes  []enums.LookerTimeFrame `json:"timeframes,omitempty" yaml:"timeframes,omitempty"`
    ConvertTZ   *bool                   `json:"convert_tz,omitempty" yaml:"convert_tz,omitempty"`
}
```

<a name="LookMLExplore"></a>
## type LookMLExplore

LookMLExplore represents an explore in LookML

```go
type LookMLExplore struct {
    Name        string       `json:"name" yaml:"name"`
    ViewName    string       `json:"view_name" yaml:"view_name"`
    Label       *string      `json:"label,omitempty" yaml:"label,omitempty"`
    Description *string      `json:"description,omitempty" yaml:"description,omitempty"`
    Hidden      *bool        `json:"hidden,omitempty" yaml:"hidden,omitempty"`
    Joins       []LookMLJoin `json:"joins,omitempty" yaml:"joins,omitempty"`
}
```

<a name="LookMLJoin"></a>
## type LookMLJoin

LookMLJoin represents a join in LookML explores

```go
type LookMLJoin struct {
    Name         string                        `json:"name" yaml:"name"`
    ViewLabel    *string                       `json:"view_label,omitempty" yaml:"view_label,omitempty"`
    SQL          *string                       `json:"sql,omitempty" yaml:"sql,omitempty"`
    Type         *enums.LookerJoinType         `json:"type,omitempty" yaml:"type,omitempty"`
    Relationship *enums.LookerRelationshipType `json:"relationship,omitempty" yaml:"relationship,omitempty"`
}
```

<a name="LookMLMeasure"></a>
## type LookMLMeasure

LookMLMeasure represents a measure in LookML

```go
type LookMLMeasure struct {
    Name                 string                       `json:"name" yaml:"name"`
    Type                 enums.LookerMeasureType      `json:"type" yaml:"type"`
    SQL                  *string                      `json:"sql,omitempty" yaml:"sql,omitempty"`
    Label                *string                      `json:"label,omitempty" yaml:"label,omitempty"`
    Description          *string                      `json:"description,omitempty" yaml:"description,omitempty"`
    Hidden               *bool                        `json:"hidden,omitempty" yaml:"hidden,omitempty"`
    GroupLabel           *string                      `json:"group_label,omitempty" yaml:"group_label,omitempty"`
    ValueFormatName      *enums.LookerValueFormatName `json:"value_format_name,omitempty" yaml:"value_format_name,omitempty"`
    Approximate          *bool                        `json:"approximate,omitempty" yaml:"approximate,omitempty"`
    ApproximateThreshold *int                         `json:"approximate_threshold,omitempty" yaml:"approximate_threshold,omitempty"`
    Precision            *int                         `json:"precision,omitempty" yaml:"precision,omitempty"`
    SQLDistinctKey       *string                      `json:"sql_distinct_key,omitempty" yaml:"sql_distinct_key,omitempty"`
    Percentile           *int                         `json:"percentile,omitempty" yaml:"percentile,omitempty"`
    Filters              []DbtMetaLookerMeasureFilter `json:"filters,omitempty" yaml:"filters,omitempty"`
}
```

<a name="LookMLMeasure.Validate"></a>
### func \(\*LookMLMeasure\) Validate

```go
func (m *LookMLMeasure) Validate() error
```

Validate checks if the measure has all required fields and valid attributes

<a name="LookMLView"></a>
## type LookMLView

LookMLView represents a view in LookML

```go
type LookMLView struct {
    Name            string                 `json:"name" yaml:"name"`
    SQLTableName    string                 `json:"sql_table_name" yaml:"sql_table_name"`
    Label           *string                `json:"label,omitempty" yaml:"label,omitempty"`
    Description     *string                `json:"description,omitempty" yaml:"description,omitempty"`
    Hidden          *bool                  `json:"hidden,omitempty" yaml:"hidden,omitempty"`
    Dimensions      []LookMLDimension      `json:"dimensions,omitempty" yaml:"dimensions,omitempty"`
    DimensionGroups []LookMLDimensionGroup `json:"dimension_groups,omitempty" yaml:"dimension_groups,omitempty"`
    Measures        []LookMLMeasure        `json:"measures,omitempty" yaml:"measures,omitempty"`
}
```

<a name="LookMLView.Validate"></a>
### func \(\*LookMLView\) Validate

```go
func (v *LookMLView) Validate() error
```

Validate checks if the view has all required fields and validates child elements

<a name="LookViewFile"></a>
## type LookViewFile

LookViewFile represents a file in a looker view directory

```go
type LookViewFile struct {
    Filename string `json:"filename" yaml:"filename"`
    Contents string `json:"contents" yaml:"contents"`
    Schema   string `json:"schema" yaml:"schema"`
}
```

<a name="NestedArrayRules"></a>
## type NestedArrayRules

NestedArrayRules encapsulates business rules for nested array processing. It determines which nested arrays should be processed based on their depth in the column hierarchy.

```go
type NestedArrayRules struct {
    // contains filtered or unexported fields
}
```

<a name="NewNestedArrayRules"></a>
### func NewNestedArrayRules

```go
func NewNestedArrayRules() *NestedArrayRules
```

NewNestedArrayRules creates a new NestedArrayRules instance with default settings.

<a name="NewNestedArrayRulesWithDepth"></a>
### func NewNestedArrayRulesWithDepth

```go
func NewNestedArrayRulesWithDepth(maxDepth int) *NestedArrayRules
```

NewNestedArrayRulesWithDepth creates a new NestedArrayRules instance with custom max depth.

<a name="NestedArrayRules.GetArrayDepth"></a>
### func \(\*NestedArrayRules\) GetArrayDepth

```go
func (r *NestedArrayRules) GetArrayDepth(arrayPath string) int
```

GetArrayDepth returns the nesting level of an array based on its path. The depth is calculated by counting dots in the path and adding 1.

Examples:

- "items" → 1 \(0 dots\)
- "items.subitems" → 2 \(1 dot\)
- "items.subitems.details" → 3 \(2 dots\)
- "items.subitems.details.meta" → 4 \(3 dots\)

<a name="NestedArrayRules.GetMaxDepth"></a>
### func \(\*NestedArrayRules\) GetMaxDepth

```go
func (r *NestedArrayRules) GetMaxDepth() int
```

GetMaxDepth returns the maximum allowed nesting depth.

<a name="NestedArrayRules.IsValidArrayPath"></a>
### func \(\*NestedArrayRules\) IsValidArrayPath

```go
func (r *NestedArrayRules) IsValidArrayPath(arrayPath string) bool
```

IsValidArrayPath checks if the array path is valid \(non\-empty and not too deep\).

<a name="NestedArrayRules.ShouldProcessArray"></a>
### func \(\*NestedArrayRules\) ShouldProcessArray

```go
func (r *NestedArrayRules) ShouldProcessArray(arrayPath string) bool
```

ShouldProcessArray determines if an array at the given path should be processed based on its nesting depth.

Examples:

- "items" \(level 1\) → true
- "items.subitems" \(level 2\) → true
- "items.subitems.details" \(level 3\) → true
- "items.subitems.details.meta" \(level 4\) → false
- "" \(empty\) → false

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
